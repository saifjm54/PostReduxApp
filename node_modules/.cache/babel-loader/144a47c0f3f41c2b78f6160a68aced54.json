{"ast":null,"code":"import { createSlice, createAsyncThunk, createEntityAdapter } from '@reduxjs/toolkit';\nimport { client } from '../../api/client';\nexport const fetchNotifications = createAsyncThunk('notifications/fetchNotifications', async (_, _ref) => {\n  let {\n    getState\n  } = _ref;\n  const allNotifications = selectAllNotifications(getState());\n  const [latestNotification] = allNotifications;\n  const latestTimestamp = latestNotification ? latestNotification.date : '';\n  const response = await client.get(`/fakeApi/notifications?since=${latestTimestamp}`);\n  return response.data;\n});\nconst notificationsAdapter = createEntityAdapter({\n  sortComparer: (a, b) => b.date.localeCompare(a.date)\n});\nconst notificationsSlice = createSlice({\n  name: 'notifications',\n  initialState: notificationsAdapter.getInitialState(),\n  reducers: {\n    allNotificationsRead(state, action) {\n      // we have to use Object.values(state.entities) to get an array of those notifications and loop over that.\n      Object.values(state.entities).forEach(notification => {\n        notification.read = true;\n      });\n    }\n  },\n  extraReducers(builder) {\n    builder.addCase(fetchNotifications.fulfilled, (state, action) => {\n      notificationsAdapter.upsertMany(state, action.payload);\n      // Sort with newest first\n      Object.values(state, entities).forEach(notification => {\n        notification.isNew = !notification.read;\n      });\n    });\n  }\n});\nexport const {\n  allNotificationsRead\n} = notificationsSlice.actions;\nexport default notificationsSlice.reducer;\nexport const {\n  selectAll: selectAllNotifications\n} = notificationsAdapter.getSelectors(state => state.notifications);","map":{"version":3,"names":["createSlice","createAsyncThunk","createEntityAdapter","client","fetchNotifications","_","_ref","getState","allNotifications","selectAllNotifications","latestNotification","latestTimestamp","date","response","get","data","notificationsAdapter","sortComparer","a","b","localeCompare","notificationsSlice","name","initialState","getInitialState","reducers","allNotificationsRead","state","action","Object","values","entities","forEach","notification","read","extraReducers","builder","addCase","fulfilled","upsertMany","payload","isNew","actions","reducer","selectAll","getSelectors","notifications"],"sources":["/home/saif/Documents/Proxym/redux-essentials-example-app/src/features/notifications/notificationsSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk, createEntityAdapter } from '@reduxjs/toolkit'\n\nimport { client } from '../../api/client'\n\nexport const fetchNotifications = createAsyncThunk(\n  'notifications/fetchNotifications',\n  async (_, { getState }) => {\n    const allNotifications = selectAllNotifications(getState())\n    const [latestNotification] = allNotifications\n    const latestTimestamp = latestNotification ? latestNotification.date : ''\n    const response = await client.get(\n      `/fakeApi/notifications?since=${latestTimestamp}`\n    )\n    return response.data\n  }\n)\nconst notificationsAdapter = createEntityAdapter({\n  sortComparer: (a,b) => b.date.localeCompare(a.date)\n}) \n\n\nconst notificationsSlice = createSlice({\n  name: 'notifications',\n  initialState: notificationsAdapter.getInitialState(),\n  reducers: {\n    allNotificationsRead(state,action) {\n      // we have to use Object.values(state.entities) to get an array of those notifications and loop over that.\n      Object.values(state.entities).forEach(notification => {\n        notification.read = true\n      })\n    }\n  },\n  extraReducers(builder) {\n    builder.addCase(fetchNotifications.fulfilled, (state, action) => {\n      notificationsAdapter.upsertMany(state,action.payload)\n      // Sort with newest first\n      Object.values(state,entities).forEach(notification => {\n        notification.isNew = !notification.read\n      })\n    })\n  }\n})\n\nexport const { allNotificationsRead } = notificationsSlice.actions\nexport default notificationsSlice.reducer\n\nexport const {\n  selectAll: selectAllNotifications\n} = notificationsAdapter.getSelectors(state => state.notifications)"],"mappings":"AAAA,SAASA,WAAW,EAAEC,gBAAgB,EAAEC,mBAAmB,QAAQ,kBAAkB;AAErF,SAASC,MAAM,QAAQ,kBAAkB;AAEzC,OAAO,MAAMC,kBAAkB,GAAGH,gBAAgB,CAChD,kCAAkC,EAClC,OAAOI,CAAC,EAAAC,IAAA,KAAmB;EAAA,IAAjB;IAAEC;EAAS,CAAC,GAAAD,IAAA;EACpB,MAAME,gBAAgB,GAAGC,sBAAsB,CAACF,QAAQ,CAAC,CAAC,CAAC;EAC3D,MAAM,CAACG,kBAAkB,CAAC,GAAGF,gBAAgB;EAC7C,MAAMG,eAAe,GAAGD,kBAAkB,GAAGA,kBAAkB,CAACE,IAAI,GAAG,EAAE;EACzE,MAAMC,QAAQ,GAAG,MAAMV,MAAM,CAACW,GAAG,CAC9B,gCAA+BH,eAAgB,EAClD,CAAC;EACD,OAAOE,QAAQ,CAACE,IAAI;AACtB,CACF,CAAC;AACD,MAAMC,oBAAoB,GAAGd,mBAAmB,CAAC;EAC/Ce,YAAY,EAAEA,CAACC,CAAC,EAACC,CAAC,KAAKA,CAAC,CAACP,IAAI,CAACQ,aAAa,CAACF,CAAC,CAACN,IAAI;AACpD,CAAC,CAAC;AAGF,MAAMS,kBAAkB,GAAGrB,WAAW,CAAC;EACrCsB,IAAI,EAAE,eAAe;EACrBC,YAAY,EAAEP,oBAAoB,CAACQ,eAAe,CAAC,CAAC;EACpDC,QAAQ,EAAE;IACRC,oBAAoBA,CAACC,KAAK,EAACC,MAAM,EAAE;MACjC;MACAC,MAAM,CAACC,MAAM,CAACH,KAAK,CAACI,QAAQ,CAAC,CAACC,OAAO,CAACC,YAAY,IAAI;QACpDA,YAAY,CAACC,IAAI,GAAG,IAAI;MAC1B,CAAC,CAAC;IACJ;EACF,CAAC;EACDC,aAAaA,CAACC,OAAO,EAAE;IACrBA,OAAO,CAACC,OAAO,CAACjC,kBAAkB,CAACkC,SAAS,EAAE,CAACX,KAAK,EAAEC,MAAM,KAAK;MAC/DZ,oBAAoB,CAACuB,UAAU,CAACZ,KAAK,EAACC,MAAM,CAACY,OAAO,CAAC;MACrD;MACAX,MAAM,CAACC,MAAM,CAACH,KAAK,EAACI,QAAQ,CAAC,CAACC,OAAO,CAACC,YAAY,IAAI;QACpDA,YAAY,CAACQ,KAAK,GAAG,CAACR,YAAY,CAACC,IAAI;MACzC,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;AACF,CAAC,CAAC;AAEF,OAAO,MAAM;EAAER;AAAqB,CAAC,GAAGL,kBAAkB,CAACqB,OAAO;AAClE,eAAerB,kBAAkB,CAACsB,OAAO;AAEzC,OAAO,MAAM;EACXC,SAAS,EAAEnC;AACb,CAAC,GAAGO,oBAAoB,CAAC6B,YAAY,CAAClB,KAAK,IAAIA,KAAK,CAACmB,aAAa,CAAC"},"metadata":{},"sourceType":"module"}